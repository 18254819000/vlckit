From c7f8367e0e5fef23db8f9a0498cbc5834fc57af2 Mon Sep 17 00:00:00 2001
From: Thomas Guillem <thomas@gllm.fr>
Date: Mon, 17 Jul 2017 17:03:24 +0200
Subject: [PATCH 16/16] Replace thread local with pthread TSD

---
 src/misc/interrupt.c | 34 ++++++++++++++++++++--------------
 src/misc/variables.c | 13 ++++++++++---
 2 files changed, 30 insertions(+), 17 deletions(-)

diff --git a/src/misc/interrupt.c b/src/misc/interrupt.c
index 3fafaa4183..7fdc7b8b96 100644
--- a/src/misc/interrupt.c
+++ b/src/misc/interrupt.c
@@ -43,13 +43,20 @@
 #include "interrupt.h"
 #include "libvlc.h"
 
-static thread_local vlc_interrupt_t *vlc_interrupt_var;
+#include <pthread.h>
+static pthread_key_t vlc_interrupt_var_key;
+static pthread_once_t vlc_interrupt_var_key_once = PTHREAD_ONCE_INIT;
+static void vlc_interrupt_var_key_create()
+{
+    pthread_key_create(&vlc_interrupt_var_key, NULL);
+}
 
 /**
  * Initializes an interruption context.
  */
 void vlc_interrupt_init(vlc_interrupt_t *ctx)
 {
+    pthread_once(&vlc_interrupt_var_key_once, vlc_interrupt_var_key_create);
     vlc_mutex_init(&ctx->lock);
     ctx->interrupted = false;
     atomic_init(&ctx->killed, false);
@@ -98,9 +105,8 @@ void vlc_interrupt_raise(vlc_interrupt_t *ctx)
 
 vlc_interrupt_t *vlc_interrupt_set(vlc_interrupt_t *newctx)
 {
-    vlc_interrupt_t *oldctx = vlc_interrupt_var;
-
-    vlc_interrupt_var = newctx;
+    vlc_interrupt_t *oldctx = pthread_getspecific(vlc_interrupt_var_key);
+    pthread_setspecific(vlc_interrupt_var_key, newctx);
     return oldctx;
 }
 
@@ -115,7 +121,7 @@ static void vlc_interrupt_prepare(vlc_interrupt_t *ctx,
                                   void (*cb)(void *), void *data)
 {
     assert(ctx != NULL);
-    assert(ctx == vlc_interrupt_var);
+    assert(ctx == pthread_getspecific(vlc_interrupt_var_key));
 
     vlc_mutex_lock(&ctx->lock);
     assert(ctx->callback == NULL);
@@ -143,7 +149,7 @@ static int vlc_interrupt_finish(vlc_interrupt_t *ctx)
     int ret = 0;
 
     assert(ctx != NULL);
-    assert(ctx == vlc_interrupt_var);
+    assert(ctx == pthread_getspecific(vlc_interrupt_var_key));
 
     /* Wait for pending callbacks to prevent access by other threads. */
     vlc_mutex_lock(&ctx->lock);
@@ -159,14 +165,14 @@ static int vlc_interrupt_finish(vlc_interrupt_t *ctx)
 
 void vlc_interrupt_register(void (*cb)(void *), void *opaque)
 {
-    vlc_interrupt_t *ctx = vlc_interrupt_var;
+    vlc_interrupt_t *ctx = pthread_getspecific(vlc_interrupt_var_key);
     if (ctx != NULL)
         vlc_interrupt_prepare(ctx, cb, opaque);
 }
 
 int vlc_interrupt_unregister(void)
 {
-    vlc_interrupt_t *ctx = vlc_interrupt_var;
+    vlc_interrupt_t *ctx = pthread_getspecific(vlc_interrupt_var_key);
     return (ctx != NULL) ? vlc_interrupt_finish(ctx) : 0;
 }
 
@@ -185,7 +191,7 @@ void vlc_interrupt_kill(vlc_interrupt_t *ctx)
 
 bool vlc_killed(void)
 {
-    vlc_interrupt_t *ctx = vlc_interrupt_var;
+    vlc_interrupt_t *ctx = pthread_getspecific(vlc_interrupt_var_key);
 
     return (ctx != NULL) && atomic_load(&ctx->killed);
 }
@@ -197,7 +203,7 @@ static void vlc_interrupt_sem(void *opaque)
 
 int vlc_sem_wait_i11e(vlc_sem_t *sem)
 {
-    vlc_interrupt_t *ctx = vlc_interrupt_var;
+    vlc_interrupt_t *ctx = pthread_getspecific(vlc_interrupt_var_key);
     if (ctx == NULL)
         return vlc_sem_wait(sem), 0;
 
@@ -227,7 +233,7 @@ static void vlc_mwait_i11e_cleanup(void *opaque)
 
 int vlc_mwait_i11e(mtime_t deadline)
 {
-    vlc_interrupt_t *ctx = vlc_interrupt_var;
+    vlc_interrupt_t *ctx = pthread_getspecific(vlc_interrupt_var_key);
     if (ctx == NULL)
         return mwait(deadline), 0;
 
@@ -262,7 +268,7 @@ void vlc_interrupt_forward_start(vlc_interrupt_t *to, void *data[2])
 {
     data[0] = data[1] = NULL;
 
-    vlc_interrupt_t *from = vlc_interrupt_var;
+    vlc_interrupt_t *from = pthread_getspecific(vlc_interrupt_var_key);
     if (from == NULL)
         return;
 
@@ -371,7 +377,7 @@ static int vlc_poll_i11e_inner(struct pollfd *restrict fds, unsigned nfds,
 
 int vlc_poll_i11e(struct pollfd *fds, unsigned nfds, int timeout)
 {
-    vlc_interrupt_t *ctx = vlc_interrupt_var;
+    vlc_interrupt_t *ctx = pthread_getspecific(vlc_interrupt_var_key);
     if (ctx == NULL)
         return poll(fds, nfds, timeout);
 
@@ -568,7 +574,7 @@ static void vlc_poll_i11e_cleanup(void *opaque)
 
 int vlc_poll_i11e(struct pollfd *fds, unsigned nfds, int timeout)
 {
-    vlc_interrupt_t *ctx = vlc_interrupt_var;
+    vlc_interrupt_t *ctx = pthread_getspecific(vlc_interrupt_var_key);
     if (ctx == NULL)
         return vlc_poll(fds, nfds, timeout);
 
diff --git a/src/misc/variables.c b/src/misc/variables.c
index 87a9c27478..2b05526162 100644
--- a/src/misc/variables.c
+++ b/src/misc/variables.c
@@ -1378,7 +1378,13 @@ void DumpVariables(vlc_object_t *obj)
     vlc_mutex_unlock(&vlc_internals(obj)->var_lock);
 }
 
-static thread_local void *twalk_ctx;
+#include <pthread.h>
+static pthread_key_t twalk_ctx_key;
+static pthread_once_t twalk_ctx_key_once = PTHREAD_ONCE_INIT;
+static void twalk_ctx_key_create()
+{
+    pthread_key_create(&twalk_ctx_key, NULL);
+}
 
 static void TwalkGetNames(const void *data, const VISIT which, const int depth)
 {
@@ -1387,7 +1393,7 @@ static void TwalkGetNames(const void *data, const VISIT which, const int depth)
     (void) depth;
 
     const variable_t *var = *(const variable_t **)data;
-    DECL_ARRAY(char *) *names = twalk_ctx;
+    DECL_ARRAY(char *) *names = pthread_getspecific(twalk_ctx_key);
     char *dup = strdup(var->psz_name);
     if (dup != NULL)
         ARRAY_APPEND(*names, dup);
@@ -1400,7 +1406,8 @@ char **var_GetAllNames(vlc_object_t *obj)
     DECL_ARRAY(char *) names;
     ARRAY_INIT(names);
 
-    twalk_ctx = &names;
+    pthread_once(&twalk_ctx_key_once, twalk_ctx_key_create);
+    pthread_setspecific(twalk_ctx_key, &names);
     vlc_mutex_lock(&priv->var_lock);
     twalk(priv->var_root, TwalkGetNames);
     vlc_mutex_unlock(&priv->var_lock);
-- 
2.11.0

